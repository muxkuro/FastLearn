-- MySQL dump 10.13  Distrib 8.0.21, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: users
-- ------------------------------------------------------
-- Server version	8.0.21

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `everyone`
--

DROP TABLE IF EXISTS `everyone`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `everyone` (
  `id` int DEFAULT NULL,
  `surname` varchar(20) DEFAULT NULL,
  `password` varchar(10) DEFAULT NULL,
  `result` varchar(5) DEFAULT NULL,
  `session` int DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `everyone`
--

LOCK TABLES `everyone` WRITE;
/*!40000 ALTER TABLE `everyone` DISABLE KEYS */;
INSERT INTO `everyone` VALUES (1,'Боцу','AS1921','20',52),(2,'Голиченко','AS1922','30',0),(3,'Гребинча','AS1923','100',24),(4,'Давлитшин','AS1924','30',0),(5,'Дымовский','AS1925','100',0),(6,'Кирица','AS1926','30',0),(7,'Компан','AS1927','30',0),(8,'Кучин','AS1928','30',0),(9,'Линда','AS1929','30',0),(10,'Марченко','AS19210','30',0),(11,'Мацнев','AS19211','30',0),(12,'Пантелеев','AS19212','30',1),(13,'Перлей','AS19213','30',0),(14,'Ребрий','AS19214','30',0),(15,'Савченко','AS19215','30',0),(16,'Сушко','AS19216','30',0),(17,'Таушанжи','AS19217','30',0),(18,'Толстопят','AS19218','30',0),(19,'Фомина','AS19219','30',0),(20,'Чан Ли','AS19220','30',0),(21,'Чуприна','AS19221','30',0),(22,'Шаров','AS19222','30',0),(23,'Хаммуда','AS19223','30',0);
/*!40000 ALTER TABLE `everyone` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `lessons`
--

DROP TABLE IF EXISTS `lessons`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `lessons` (
  `id` int NOT NULL AUTO_INCREMENT,
  `lesson` text NOT NULL,
  `answers` text NOT NULL,
  `button1` tinyint NOT NULL,
  `button2` tinyint NOT NULL,
  `button3` tinyint NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `lessons`
--

LOCK TABLES `lessons` WRITE;
/*!40000 ALTER TABLE `lessons` DISABLE KEYS */;
INSERT INTO `lessons` VALUES (1,'Привет\nGhbdtn\ndhnsdfksdfsdf\nОператоры сравнения\n\nРяд операторов определяются парами. Например, если мы определяем оператор ==, то необходимо также определить и оператор !=. А при определении оператора < надо также определять функцию для оператора >.\n\nОператоры присвоения\n\nОператоры присвоения обычно возвращает ссылку на свой левый операнд.\n\nОперации инкремента и декремента\n\nОсобую сложность может представлять переопределение операций инкремента и декремента, поскольку нам надо определить и префиксную, и постфиксную форму для этих операторов.\n\nПрефиксные операторы должны возвращать ссылку на текущий объект, который можно получить с помощью указателя this:\nCounter& operator++ ()\n{\n    seconds += 5;\n    return *this;\n}\n\nВ самой функции можно определить некоторую логику по инкременту значения. В данном случае количество секунд увеличивается на 5.\n\nПостфиксные операторы должны возвращать значение объекта до инкремента, то есть предыдущее состояние объекта. Чтобы постфиксная форма отличалась от префиксной, постфиксные версии получают дополнительный параметр типа int, который не используется. Хотя в принципе мы можем его использовать.\n\nCounter operator++ (int)\n{\n    Counter prev = *this;\n    ++*this;\n    return prev;\n}\n\n','пукпук',1,1,1),(2,'null','которые уже определены в С++',1,1,1),(3,'null','оператор',1,1,1),(4,'Операторы сравнения\n\nРяд операторов перегружаются парами. Например, если мы определяем оператор ==, то необходимо также определить и оператор !=. А при определении оператора < надо также определять функцию для оператора >.\n\nОператоры присвоения\n\nОператоры присвоения обычно возвращает ссылку на свой левый операнд:\n\nОперации инкремента и декремента\n\nОсобую сложность может представлять переопределение операций инкремента и декремента, поскольку нам надо определить и префиксную, и постфиксную форму для этих операторов.\n\nПрефиксные операторы должны возвращать ссылку на текущий объект, который можно получить с помощью указателя this:\nCounter& operator++ ()\n{\n    seconds += 5;\n    return *this;\n}\n\nВ самой функции можно определить некоторую логику по инкременту значения. В данном случае количество секунд увеличивается на 5.\n\nПостфиксные операторы должны возвращать значение объекта до инкремента, то есть предыдущее состояние объекта. Чтобы постфиксная форма отличалась от префиксной постфиксные версии получают дополнительный параметр типа int, который не используется. Хотя в принципе мы можем его использовать.\n\nCounter operator++ (int)\n{\n    Counter prev = *this;\n    ++*this;\n    return prev;\n}\n\n','предыдущее состояние объекта',1,1,1),(5,'null','возвращают ссылку на свой левый операнд',1,1,1),(6,'null','операторы сравнения',1,1,1),(7,'Приоритеты операторов в C ++\n\nПриоритет оператора определяет группировку терминов в выражении. Это влияет на оценку выражения. Некоторые операторы имеют более высокий приоритет, чем другие; например, оператор умножения имеет более высокий приоритет, чем оператор сложения -\n\nНапример, x = 7 + 3 * 2; здесь x назначается 13, а не 20, потому что оператор * имеет более высокий приоритет, чем +, поэтому он сначала умножается на 3 * 2, а затем добавляется в 7.\n\nЗдесь операторы с наивысшим приоритетом появляются в верхней части таблицы, а нижние - внизу. Внутри выражения сначала будут оцениваться операторы с более высоким приоритетом.\n\nКатегория 	Оператор 	Ассоциативность \nпостфикс 	() [] ->. ++ - -  	Слева направо \nОдинарный 	+ -! ~ ++ - - (тип) * & sizeof 	Справа налево \nMultiplicative  	* /% 	Слева направо \nприсадка  	+ - 	Слева направо \nсдвиг  	<< >> 	Слева направо \nреляционный  	<<=>> = 	Слева направо \nравенство  	==! = 	Слева направо \nПобитовое AND 	& 	Слева направо \nПобитовое XOR 	^ 	Слева направо \nПобитовое OR 	| 	Слева направо \nЛогические AND 	&& 	Слева направо \nЛогический OR 	|| 	Слева направо \nусловный 	?: 	Справа налево \nприсваивание 	= + = - = * = / =% = >> = << = & = ^ = | = 	Справа налево \nзапятая 	, 	Слева направо','aqweqwe',1,1,1),(8,'null','сравнения',1,1,1),(9,'null','да',1,1,1);
/*!40000 ALTER TABLE `lessons` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `teacher`
--

DROP TABLE IF EXISTS `teacher`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `teacher` (
  `Id` int DEFAULT NULL,
  `surname` varchar(20) DEFAULT NULL,
  `password` varchar(20) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `teacher`
--

LOCK TABLES `teacher` WRITE;
/*!40000 ALTER TABLE `teacher` DISABLE KEYS */;
INSERT INTO `teacher` VALUES (1,'Кунгурцев','AS1920');
/*!40000 ALTER TABLE `teacher` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-04-19 20:23:01
-- MySQL dump 10.13  Distrib 8.0.21, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: people
-- ------------------------------------------------------
-- Server version	8.0.21

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `learners`
--

DROP TABLE IF EXISTS `learners`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `learners` (
  `id` int NOT NULL,
  `login` varchar(45) DEFAULT NULL,
  `password` varchar(45) DEFAULT NULL,
  `mark` varchar(45) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `learners`
--

LOCK TABLES `learners` WRITE;
/*!40000 ALTER TABLE `learners` DISABLE KEYS */;
INSERT INTO `learners` VALUES (1,'Гребинча','password','40'),(1,'Боцу','123321','40'),(1,'Голиченко','1221',NULL),(2,'Голиченко','122121','40');
/*!40000 ALTER TABLE `learners` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `lessons`
--

DROP TABLE IF EXISTS `lessons`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `lessons` (
  `idlessons` int NOT NULL,
  `lesson` varchar(10000) DEFAULT NULL,
  `answers` varchar(45) DEFAULT NULL,
  PRIMARY KEY (`idlessons`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `lessons`
--

LOCK TABLES `lessons` WRITE;
/*!40000 ALTER TABLE `lessons` DISABLE KEYS */;
INSERT INTO `lessons` VALUES (1,'Цикл while\nВ языке C++ существует три вида циклов: цикл while c предусловием, цикл while с постусловием, цикл for.\n\nЦикл while (\"пока\") с предусловием\nЦикл while с предусловием позволяет выполнить одну и ту же последовательность действий пока проверяемое условие истинно. При этом условие записывается до тела цикла и проверяется до выполнения тела цикла.\n\nПри выполнении цикла while сначала проверяется условие. Если оно ложно, то цикл не выполняется и управление передается на следующую инструкцию после тела цикла while. Если условие истинно, то выполняется инструкция, после чего условие проверяется снова и снова выполняется инструкция. Так продолжается до тех пор, пока условие будет истинно. Как только условие станет ложно, работа цикла завершится и управление передастся следующей инструкции после цикла.\n\nСинтаксис цикла while (\"пока\") c предусловием такой:\n\n     while (условие)\n     {\n         блок инструкций\n     }\n\nСледующий фрагмент программы напечатает на экран квадраты всех целых чисел от 1 до 10:\n\n     int i=1;\n     while (i<=10)\n     {\n         cout<<i*i<<endl;\n         ++i;\n     }\n\nВ этом примере переменная i внутри цикла изменяется от 1 до 10. Такая переменная, значение которой меняется с каждым новым проходом цикла, называется счетчиком. Заметим, что после выполнения этого фрагмента значение переменной i будет равно 11, поскольку именно при i==11 условие i<=10 впервые перестанет выполняться.\n\nВ следующем примере цикл используется для того, чтобы найти количество знаков в десятичной записи целочисленной переменной i.\n\n     int Ndigits=0;\n     while(n!=0)\n     {\n         Ndigits=Ndigits+1;\n         n=n/10;\n     }\n\nВнутри цикла значение переменной n уменьшается в 10 раз до тех пор, пока она не станет равна 0. Уменьшение целочисленной переменной в 10 раз (с использованием целочисленного деления) эквивалентно отбрасыванию последней цифры этой переменной.\n\nЦикл while (\"пока\") с постусловием\nЦикл \"пока\" с постусловием отличается от цикла с предусловием тем, что сначала выполняется блок цикла, а потом проверяется условие. Если условие истинно, то цикл будет выполнен еще раз, и так до тех пор, пока условие будет истинно. Синтаксис цикла с постусловием такой (обратите внимание на обязательную точку с запятой после условия):\n\n     do\n     {\n         Блок инструкций\n     }\n     while (условие);\n\nПоскольку условие проверяется после выполнения тела цикла, то блок цикла с постусловием всегда будет выполнен хотя бы один раз, независимо от истинности условия. Это может привести к ошибкам, поэтому использовать цикл while с постусловием следует только тогда, когда это действительно упрощает алгоритм.\n','1'),(2,'Цикл с постусловием do...while\nОбщая форма записи\n \n \n do {\n  БлокОпераций;\n} while (Условие);\n\nЦикл do...while — это цикл с постусловием, где истинность выражения, проверяющего Условие проверяется после выполнения Блока Операций, заключенного в фигурные скобки. Тело цикла выполняется до тех пор, пока выражение, проверяющее Условие, не станет ложным, то есть тело цикла с постусловием выполнится хотя бы один раз.\n\nИспользовать цикл do...while лучше в тех случаях, когда должна быть выполнена хотя бы одна итерация, либо когда инициализация объектов, участвующих в проверке условия, происходит внутри тела цикла.\n\nПример на Си. Проверка, что пользователь ввел число от 0 до 10\n\n#define _CRT_SECURE_NO_WARNINGS // для возможности использования scanf\n#include <stdio.h>\n#include <stdlib.h> // для использования функции system()\nint main() {\n  int num;             // объявляем целую переменную для числа\n  system(\"chcp 1251\"); // переходим на русский язык в консоли\n  system(\"cls\");       // очищаем экран\n  do {\n    printf(\"Введите число от 0 до 10: \"); // приглашение пользователю\n    scanf(\"%d\", &num); // ввод числа\n  } while ((num < 0) || (num > 10)); // повторяем цикл пока num<0 или num>10\n  printf(\"Вы ввели число %d\", num); // выводим введенное значение num - от 0 до 10\n  getchar(); getchar();\n  return 0;\n}\n\nПараметрический цикл for\nОбщая форма записи\n \n \n \n for (Инициализация; Условие; Модификация)\n{\n  БлокОпераций;\n}\n\n\nfor — параметрический цикл (цикл с фиксированным числом повторений). Для организации такого цикла необходимо осуществить три операции:\nИнициализация - присваивание параметру цикла начального значения;\nУсловие - проверка условия повторения цикла, чаще всего - сравнение величины параметра с некоторым граничным значением;\nМодификация - изменение значения параметра для следующего прохождения тела цикла.\n \nЭти три операции записываются в скобках и разделяются точкой с запятой ;;. Как правило, параметром цикла является целочисленная переменная.\nИнициализация параметра осуществляется только один раз — когда цикл for начинает выполняться.\nПроверка Условия повторения цикла осуществляется перед каждым возможным выполнением тела цикла. Когда выражение, проверяющее Условие становится ложным (равным нулю), цикл завершается. Модификация параметра осуществляется в конце каждого выполнения тела цикла. Параметр может как увеличиваться, так и уменьшаться.\n\nПример на Си: Посчитать сумму чисел от 1 до введенного k\n\n#define _CRT_SECURE_NO_WARNINGS // для возможности использования scanf\n#include <stdio.h>\nint main() {\n  int k;  // объявляем целую переменную key\n  int sum = 0; // начальное значение суммы равно 0\n  printf(\"k = \");\n  scanf(\"%d\", &k);   // вводим значение переменной k\n  for(int i=1; i<=k; i++) // цикл для переменной i от 1 до k с шагом 1\n  {\n    sum = sum + i; // добавляем значение i к сумме\n  }\n  printf(\"sum = %d\\n\", sum); // вывод значения суммы\n  getchar(); getchar();\n  return 0;\n}\n\nВ записи цикла for можно опустить одно или несколько выражений, но нельзя опускать точку с запятой, разделяющие три составляющие цикла.\nКод предыдущего примера можно представить в виде\n\n#define _CRT_SECURE_NO_WARNINGS // для возможности использования scanf\n#include <stdio.h>\nint main() {\n  int k;  // объявляем целую переменную key\n  int sum = 0; // начальное значение суммы равно 0\n  printf(\"k = \");\n  scanf(\"%d\", &k);   // вводим значение переменной k\n  int i=1;\n  for(; i<=k; i++) // цикл для переменной i от 1 до k с шагом 1\n  {\n    sum = sum + i; // добавляем значение i к сумме\n  }\n  printf(\"sum = %d\\n\", sum); // вывод значения суммы\n  getchar(); getchar();\n  return 0;\n}\n\n\nПараметры, находящиеся в выражениях в заголовке цикла можно изменить при выполнении операции в теле цикла, например\n\n#define _CRT_SECURE_NO_WARNINGS // для возможности использования scanf\n#include <stdio.h>\nint main() {\n  int k;  // объявляем целую переменную key\n  int sum = 0; // начальное значение суммы равно 0\n  printf(\"k = \");\n  scanf(\"%d\", &k);   // вводим значение переменной k\n  for(int i=1; i<=k; ) // цикл для переменной i от 1 до k с шагом 1\n  {\n    sum = sum + i; // добавляем значение i к сумме\n    i++;           // добавляем 1 к значению i\n\n  }\n  printf(\"sum = %d\\n\", sum); // вывод значения суммы\n  getchar(); getchar();\n  return 0;\n}\n\n\nВ цикле for может использоваться операция запятая - , - для разделения нескольких выражений. Это позволяет включить в спецификацию цикла несколько инициализирующих или корректирующих выражений. Выражения, к которым применяется операция запятая, будут вычисляться слева направо.\n\nПример на Си:\n\n#define _CRT_SECURE_NO_WARNINGS // для возможности использования scanf\n#include <stdio.h>\nint main() {\n  int k;  // объявляем целую переменную key\n  printf(\"k = \");\n  scanf(\"%d\", &k);   // вводим значение переменной k\n  for(int i=1, j=2; i<=k; i++, j+=2) // цикл для переменных\n  {                                  // (i от 1 до k с шагом 1) и (j от 2 с шагом 2)\n    printf(\"i = %d   j = %d\\n\", i, j); // выводим значения i и j\n  }\n  getchar(); getchar();\n  return 0;\n}','2'),(3,'Цикл while\n\nываываываываыва\nВ языке C++ существует три вида циклов: цикл while c предусловием, цикл while с постусловием, цикл for.\n\nЦикл while (\"пока\") с предусловием\nЦикл while с предусловием позволяет выполнить одну и ту же последовательность действий пока проверяемое условие истинно. При этом условие записывается до тела цикла и проверяется до выполнения тела цикла.\n\nПри выполнении цикла while сначала проверяется условие. Если оно ложно, то цикл не выполняется и управление передается на следующую инструкцию после тела цикла while. Если условие истинно, то выполняется инструкция, после чего условие проверяется снова и снова выполняется инструкция. Так продолжается до тех пор, пока условие будет истинно. Как только условие станет ложно, работа цикла завершится и управление передастся следующей инструкции после цикла.\n\nСинтаксис цикла while (\"пока\") c предусловием такой:\n\n     while (условие)\n     {\n         блок инструкций\n     }\n\nСледующий фрагмент программы напечатает на экран квадраты всех целых чисел от 1 до 10:\n\n     int i=1;\n     while (i<=10)\n     {\n         cout<<i*i<<endl;\n         ++i;\n     }\n\nВ этом примере переменная i внутри цикла изменяется от 1 до 10. Такая переменная, значение которой меняется с каждым новым проходом цикла, называется счетчиком. Заметим, что после выполнения этого фрагмента значение переменной i будет равно 11, поскольку именно при i==11 условие i<=10 впервые перестанет выполняться.\n\nВ следующем примере цикл используется для того, чтобы найти количество знаков в десятичной записи целочисленной переменной i.\n\n     int Ndigits=0;\n     while(n!=0)\n     {\n         Ndigits=Ndigits+1;\n         n=n/10;\n     }\n\nВнутри цикла значение переменной n уменьшается в 10 раз до тех пор, пока она не станет равна 0. Уменьшение целочисленной переменной в 10 раз (с использованием целочисленного деления) эквивалентно отбрасыванию последней цифры этой переменной.\n\nЦикл while (\"пока\") с постусловием\nЦикл \"пока\" с постусловием отличается от цикла с предусловием тем, что сначала выполняется блок цикла, а потом проверяется условие. Если условие истинно, то цикл будет выполнен еще раз, и так до тех пор, пока условие будет истинно. Синтаксис цикла с постусловием такой (обратите внимание на обязательную точку с запятой после условия):\n\n     do\n     {\n         Блок инструкций\n     }\n     while (условие);\n\nПоскольку условие проверяется после выполнения тела цикла, то блок цикла с постусловием всегда будет выполнен хотя бы один раз, независимо от истинности условия. Это может привести к ошибкам, поэтому использовать цикл while с постусловием следует только тогда, когда это действительно упрощает алгоритм.\n','3'),(4,'','4'),(5,NULL,'5');
/*!40000 ALTER TABLE `lessons` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `teachers`
--

DROP TABLE IF EXISTS `teachers`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `teachers` (
  `id` int NOT NULL,
  `login` varchar(45) DEFAULT NULL,
  `password` varchar(45) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `teachers`
--

LOCK TABLES `teachers` WRITE;
/*!40000 ALTER TABLE `teachers` DISABLE KEYS */;
INSERT INTO `teachers` VALUES (1,'Кунгурцев','111'),(1,'Кунгурцев','111');
/*!40000 ALTER TABLE `teachers` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-04-19 20:23:02
